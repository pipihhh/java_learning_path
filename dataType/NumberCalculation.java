public class NumberCalculation {
    public static void main(String[] args) {
        // int类型的计算永远不会出错,除法也不会,但是只会保留整数部分的结果
        // 在计算除0的时候,编译不会报错,会在运行时报错
        // 溢出:由于每个类型的数都存在范围的限制,如果计算结果超出了范围,会溢出,溢出不会报错但是结果会很奇怪
        int x = 2147483640;
        int y = 15;
        int sum = x + y;
        System.out.println(sum);

        // 自增 +=,-=,*=,/=
        // ++ --自加,注意++i和i++的区别

        // 位运算相关
        // 比如int的7的二进制如下00000000 0000000 0000000 00000111
        int n = 7;
        int a = n << 1;
        int b = n << 2;
        int c = n << 28;   // 01110000 0000000 0000000 00000000
        int d = n << 29;   // 11100000 0000000 0000000 00000000
        // <<的意思为 将7中的111向左移动xx位,如果超过了最大长度,则会失去那部分长度

        // 同理,>>为向右移动,如果对一个负数进行向右移动,最高位的1不动,其他数右移
        int e = n >> 1;    // 00000000 0000000 0000000 00000011
        // 如果想让符号位一起动,需使用>>>移动
        // 可以发现,<<就是在不断的x2 >>就是在不断的/2
        // 当对byte和short进行移位时,会首先把类型转为int再移位

        // 位运算，与或非
        n = 0 & 0;  // 与运算
        n = 0 | 0;  // 或运算
        n = ~0;     // 非运算
        n = 0 ^ 0;  // 异或运算
        // 对一个数进行位运算 本质上是将二个数的二进制对其之后依次进行运算
        // 类型提升,当int与short进行运算的时候,结果总为int类型,如果用一个short接收他们的运算结果,会导致编译错误

        // 强制类型转换
        int i = 12345;
        short s = (short) i; // 12345 将i强转为short类型
        // 超过范围的强转不会报错但是会出现错误的结果

        // 浮点数的运算相关
        // 浮点数的运算只有+,-,*,/,没有位运算,位移运算
        // 在计算机中浮点数虽然表示的数很大,但是浮点数常常无法精确的表示
        // 在计算机中 十进制的0.1换算成二进制是一个无限循环的小数,很显然,float和double都无法存储精确值,只能存储近似值,而0.5又可以精确的表示
        // 由于这个特点,浮点数的比较常常是不准确的,正确的做法是,将两浮点数做差再比较结果的绝对值是否小于某个很小的小数
        // 如果参与运算的两个数其中一个是整型,那么整型可以自动提升到浮点型
        // 在复杂的四则运算中,两个整数的运算不会出现自动提升的情况 1.2 + 24 / 5;
        // 溢出:在float类型/0的时候,会返回几个特殊值 NaN:Not a Number, Infinity表示无穷大,-Infinity表示负无穷大
        // 强制类型转换:在转为int时会丢弃小数部分,如果超过了整型能表示的最大值,将返回整型的最大值
        // 如果要四舍五入,可以对浮点数加上0.5


        // boolean类型,关系运算符
        // !, >, >=, <, <=, ==, !=, &&, ||这几种
        // 短路运算:如果表达式能提前结束,则后续的计算不再执行,直接返回结果
        // 三元运算符 b?x:y如果b为true则返回x否则返回y
    }
}